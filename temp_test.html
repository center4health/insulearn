<!DOCTYPE html>
<html>
  <head>
    <title>Nick - D3 sample</title>
    <script src="https://d3js.org/d3.v6.js"></script>
  </head>
  <body>
    <div id="my_chart"></div>
    <script>
      // Margin Handling - https://www.d3-graph-gallery.com/graph/line_basic.html
      // margins are basically the spacing between stuff. Kinda too lazy/complicated to figure it out myself.
      var margin = {top: 20, right: 40, bottom: 30, left: 60},
        width = 1000 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

      // Create the tag - similar to React
      let svg = d3.select("#my_chart")
        .append("svg") // add the html tag
          .attr("width", width + margin.left + margin.right) // define width attribute of svg
          .attr("height", height + margin.top + margin.bottom) // define heigth attribute of svg
        .append("g") // g is within the svg tag
          .attr("transform", `translate(${margin.left}, ${margin.top})`); // want to shift it a bit to the right, and down
          // `${}` acts like a f-string in python
      
      // function to convert string to time
      let parseTime = d3.timeParse("%Y-%m-%d %H:%M:%S")

      d3.csv("testdata/cgm.csv").then((data) => { // csv: reads in the csv -> then: after compiler finishes reading then do defined function.
        // () => {} is shorthand for function definition (parameters) => {code}
        // get the correct format and type for the data
        let formatted_data = data.map((d) => {
          return {
            datetime: parseTime(d.day + " " + d.time),
            sugar_glucose_value: parseFloat(d.sgv),
          }
        });

        // Axis Stuff
        // find the domain values
        let max_x = Math.max.apply(Math, formatted_data.map((d) => { return d.datetime; })); 
        let min_x = Math.min.apply(Math, formatted_data.map((d) => { return d.datetime; }));

        var x = d3.scaleTime()
          .domain([min_x, max_x]) // 24 hour period
          .range([0, 1000]); // want a wider x compared to y, we can do this since javascript coordinates go left to right

        svg.append("g") 
          .attr("transform", `translate(0,${height})`) // Need to push this down to the to the bottom of the graph
          .call(d3.axisBottom(x))// This appends on the last call of the svg attribute assignment (the "g" in line 20). 
          // call: Invokes the specified function exactly once
          // d3.axisBottom() returns a function. Its done this way such that it could be associated with the "g" tag

        let max_y = Math.max.apply(Math, formatted_data.map((d) => { return d.sugar_glucose_value; })); 
        let min_y = Math.min.apply(Math, formatted_data.map((d) => { return d.sugar_glucose_value; }));

        var y = d3.scaleLinear()
          .domain([0, max_y * 1.1]) // the input values. Don't want it to be cut off at max value, so we have that multiplication
          .range([height, 0]); // Javascript coordinates go from top to bottom, not bottom to right, so doing [big_value, smaller_value] should fix ordering problems

        svg.append("g") 
          .call(d3.axisLeft(y))// This appends on the last call of the svg attribute assignment (the "g" in line 20)
        
        // Line Stuff
        svg.append("path")
          .datum(formatted_data) // used by the "d" attribute later on with d3.line
          .attr("fill", "none") // if you fill it with a color value, it'll fill the area above and below the line of best fit. 
          .attr("stroke", "steelblue") // line color
          .attr("stroke-width", 1.5) // line width
          .attr("d", d3.line() // data point
            .x((d) => x(d.datetime))
            .y((d) => y(d.sugar_glucose_value))
          )
      });
    </script>
  </body>
</html>
